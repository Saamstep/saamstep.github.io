'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = build;
/**
 * # Closure Eliminator
 */

var $boundArrowFunction = Symbol('boundArrowFunction');
var $usedEval = Symbol('usedEval');

function _ref2(_ref) {
  var node = _ref.node;
  return node._generated || node._compact;
}

function _ref3(path) {
  return path.isFunction();
}

function _ref4(path) {
  return path.type !== 'ArrowFunctionExpression';
}

function _ref5(parentArrow) {
  parentArrow.node[$boundArrowFunction] = true;
}

function _enter(path) {
  var parentFunctions = path.getAncestry().filter(_ref3),
      nearestNoArrowFunction = parentFunctions.findIndex(_ref4);
  parentFunctions.slice(0, nearestNoArrowFunction).forEach(_ref5);
}

function _ref6(path) {
  return path.isFunction();
}

function _ref7(parentArrow) {
  parentArrow.node[$usedEval] = true;
}

function _enter2(path) {
  if (path.node.name === 'eval' && path.parentPath.type === 'CallExpression') {
    path.getAncestry().filter(_ref6).forEach(_ref7);
  }
}

function getNearestScopeWithLocalUsedVars(path) {
  var disableRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var scope = path.scope,
      rootScope = path.scope.getProgramParent();

  function _ref8(refPath) {
    return refPath.isDescendant(path);
  }

  do {
    scope = scope.parent;
    var bindings = scope.getAllBindings();
    for (var id in bindings) {
      if (!scope.hasOwnBinding(id)) {
        break;
      }
      var references = [].concat(bindings[id].referencePaths).concat(bindings[id].constantViolations),
          usedReferences = references.filter(_ref8);
      if (usedReferences.length) {
        return scope;
      }
    }
    if (disableRoot && scope.parent === rootScope) {
      return scope;
    }
  } while (scope.parent);
  return scope;
}

function getAttachmentPosition(bestParent, prevPath) {
  var prevParents = prevPath.getAncestry(),
      bestParentIdx = prevParents.indexOf(bestParent);
  if (-1 === bestParentIdx) {
    throw new Error('Possible parent not really in ancestry');
  }
  return prevParents.slice(1, bestParentIdx).reverse().find(function (path) {
    return (path.parentPath.isBlockStatement() || path.parentPath.isProgram()) && path.parentPath.scope !== prevPath.parentPath.scope;
  });
}

function _logAllProgram(path, label) {
  var rootNode = path.getAncestry().pop().node;
  console.error(label);
  console.error(require('babel-generator').default(rootNode).code);
  console.error('\n=======================================================\n');
}
function build(babel) {
  var t = babel.types;

  function _exit(path) {
    var node = path.node;

    if (path.node._hoisted) {
      return;
    }
    if (path.isClassMethod() || path.isObjectMethod() || node[$boundArrowFunction] || node[$usedEval]) {
      return;
    }
    if (path.findParent(_ref2)) {
      path.skip();
      return;
    }
    var bestParentScope = getHighestCompatibleHoistedScope(path);
    if (bestParentScope) {
      var attachPath = getAttachmentPosition(bestParentScope.path, path);
      if (attachPath) {
        // _logAllProgram(path, 'before');// debug
        moveToNewPosition(path, attachPath);
        // _logAllProgram(path, 'after');// debug
      }
    }
  }

  return {
    visitor: {
      Program: {
        exit: function exit(path) {
          if (babel.traverse.cache) {
            babel.traverse.cache.clear();
          } else {
            babel.traverse.clearCache();
          }
          path.scope.crawl();
          path.traverse({
            Function: {
              exit: _exit
            },
            ThisExpression: {
              enter: _enter
            },
            Identifier: {
              enter: _enter2
            }
          });
        }
      }
    }
  };

  function getHighestCompatibleHoistedScope(path) {
    var scope = getNearestScopeWithLocalUsedVars(path, path.scope.getProgramParent().path.node.sourceType !== 'module');
    if (scope !== path.scope.parent) {
      return scope;
    }
  }function moveToNewPosition(path, attachPath) {
    var node = path.node,
        scope = path.scope,
        newScope = attachPath.parentPath.scope;

    if (node.type === 'FunctionDeclaration') {
      if (newScope.bindings[node.id.name]) {
        var uid = newScope.generateUidIdentifierBasedOnNode(node.id);
        scope.rename(node.id.name, uid.name);
      }
      scope.moveBindingTo(node.id.name, newScope);
      node._hoisted = true;
      attachPath.insertBefore([node]);
      path.remove();
    } else {
      var _uid = path.parentPath.scope.generateUidIdentifierBasedOnNode(node.id),
          replacement = t.functionDeclaration(_uid, node.params, normalizeFunctionBody(node.body));
      if (node.id && node.id.name) {
        // fix for auto-generated named expression function, when node.id duplicated in AST in outer VariableDeclaration
        node.id = t.cloneDeep(node.id);
        scope.crawl();

        scope.rename(node.id.name, _uid.name);
        scope.moveBindingTo(node.id.name, newScope);
      }
      replacement.loc = node.loc;
      replacement.generator = node.generator;
      replacement.async = node.async;
      replacement._hoisted = true;
      var declarePath = attachPath.insertBefore([replacement])[0];
      path.replaceWith(t.identifier(_uid.name));
      if (!newScope.bindings[_uid.name]) {
        newScope.registerDeclaration(declarePath);
      }
      newScope.bindings[_uid.name].reference(path);
    }
  }

  /**
   * Normalize a function body so that it is always a BlockStatement.
   */
  function normalizeFunctionBody(node) {
    if (node.type !== 'BlockStatement') {
      return t.blockStatement([t.returnStatement(node)]);
    } else {
      return node;
    }
  }
}